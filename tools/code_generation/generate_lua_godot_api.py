"""
Generate a Lua file with Lua Language Server annotations based on extension_api.json
"""

import os
import json
from textwrap import dedent

from json_types import *


SRC_DIR = os.path.dirname(__file__)
DEST_DIR = os.path.join(SRC_DIR, "..", "..", "addons", "lua-gdextension", "lua_api_definitions")
API_JSON_PATH = os.path.join(SRC_DIR, "..", "..", "lib", "godot-cpp", "gdextension", "extension_api.json")

OPERATOR_MAP = {
    ## LLS doesn't really support equality operators: https://github.com/LuaLS/lua-language-server/issues/1882
    # "==": "eq",
    # "<": "lt",
    # "<=": "le",

    "+": "add",
    "-": "sub",
    "*": "mul",
    "/": "div",
    "%": "mod",
    "**": "pow",
    "unary-": "unm",

    "&": "band",
    "|": "bor",
    "^": "bxor",
    "~": "bnot",
    "<<": "shl",
    ">>": "shr",
}

KEYWORD_MAP = {
    "end": "_end",
    "function": "_function",
    "in": "_in",
    "local": "_local",
    "repeat": "_repeat",
}


def main():
    with open(API_JSON_PATH, encoding="utf-8") as f:
        extension_api: ExtensionApi = json.load(f)

    with open(os.path.join(DEST_DIR, "global_enums.lua"), "w") as f:
        _write_to_file(f, generate_global_enums(extension_api["global_enums"]))

    with open(os.path.join(DEST_DIR, "builtin_classes.lua"), "w") as f:
        _write_to_file(f, generate_builtin_classes(extension_api["builtin_classes"]))

    with open(os.path.join(DEST_DIR, "classes.lua"), "w") as f:
        _write_to_file(f, generate_classes(extension_api["classes"], extension_api["singletons"]))

    with open(os.path.join(DEST_DIR, "utility_functions.lua"), "w") as f:
        _write_to_file(f, generate_utility_functions(extension_api["utility_functions"]))


def _write_to_file(f, lines: list[str]):
    preamble = [
        "--- This file was automatically generated by generate_lua_godot_api.py",
        "--- @meta",
    ]
    f.writelines(f"{l}\n" for l in preamble + lines)


def _generate_section(name: str) -> str:
    return dedent(f"""
        -----------------------------------------------------------
        -- {name}
        -----------------------------------------------------------
    """)


def _arg_name(name: str) -> str:
    return KEYWORD_MAP.get(name, name)


def _arg_type(name: str, has_default: Any = False) -> str:
    if name == "Variant":
        arg_type = "any"
    elif name.startswith("typedarray::"):
        arg_type = f"Array[{name[len("typedarray::"):]}]"
    else:
        arg_type = name.replace(",", " | ").replace("enum::", "").replace("bitfield::", "")
    
    if has_default:
        arg_type += '?'
    return arg_type


def generate_global_enums(
    enums: list[GlobalEnumOrEnum],
) -> list[str]:
    lines = [_generate_section("Global Enums")]
    for enum in enums:
        lines.append(f"--- @alias {enum['name']} {' | '.join(f'`{value["name"]}`' for value in enum['values'])}")
        for value in enum["values"]:
            lines.append(f"{value['name']} = {value['value']}")
    lines.append("")
    return lines


def generate_builtin_classes(
    builtin_classes: list[BuiltinClass],
) -> list[str]:
    lines = [
        "--- @diagnostic disable: param-type-mismatch",
        "--- @diagnostic disable: redundant-parameter",
        _generate_section("Builtin Classes (a.k.a. Variants)"),
    ]

    # First, the definition of Variant
    lines.append(dedent("""
        --- @class Variant
        --- @overload fun(): Variant
        --- @overload fun(from: any): Variant
        --- @operator concat(any): String
        Variant = {}

        --- @param self any
        --- @return bool
        function Variant.booleanize(self) end

        --- @param self any
        --- @return Variant
        function Variant.duplicate(self) end

        --- @param method string
        --- @return Variant
        function Variant:call(method, ...) end

        --- @param method string
        --- @return Variant
        function Variant:pcall(method, ...) end

        --- @param self any
        --- @return Variant.Type
        function Variant.get_type(self) end

        --- @param self any
        --- @return string
        function Variant.get_type_name(self) end

        --- @param self any
        --- @return integer
        function Variant.hash(self) end

        --- @param self any
        --- @param recursion_count integer
        --- @return integer
        function Variant.recursive_hash(self, recursion_count) end

        --- @param other any
        --- @return bool
        function Variant.hash_compare(self, other) end
        
        --- @param self any
        --- @param type any
        --- @return bool
        function Variant.is(self, type) end
    """).lstrip())

    # Now its specializations
    for cls in builtin_classes:
        if cls["name"] == "Nil":
            continue

        lines.append(f"{_generate_section(cls['name'])}")
        if cls["name"] == "bool":
            lines.append("--- @alias bool boolean")
            lines.append("--- @return bool")
            lines.append("function bool() end")
        elif cls["name"] == "int":
            lines.append("--- @alias int integer")
            lines.append("--- @return int")
            lines.append("function int() end")
        elif cls["name"] == "float":
            lines.append("--- @alias float number")
            lines.append("--- @return float")
            lines.append("function float() end")
        else:
            can_construct_from_table = cls["name"] in ["Dictionary", "Array"]
            is_string = cls["name"] in ["String", "StringName"]

            # Header
            if is_string:
                lines.append(f"--- @alias {cls['name']} string")
                lines.append(f"{cls['name']} = string")
            else:
                lines.append(f"--- @class {cls['name']}: Variant")

                # Fields
                for member in cls.get("members", []):
                    lines.append(f"--- @field {member['name']} {member['type']}")

                # Constructors
                if can_construct_from_table:
                    lines.append(f"--- @overload fun(from: table): {cls['name']}")
                for ctor in cls["constructors"]:
                    lines.append(f"--- @overload fun({', '.join(f"{arg['name']}: {arg['type']}" for arg in ctor.get('arguments', []))}): {cls['name']}")
                
                # Other operators
                for op in cls["operators"]:
                    if op["name"] in OPERATOR_MAP:
                        lines.append(f"--- @operator {OPERATOR_MAP[op['name']]}({op.get('right_type', "")}): {op['return_type']}")

                lines.append(f"{cls['name']} = {{}}")

            # Constants
            if constants := cls.get("constants", []):
                lines.append("")
                for constant in constants:
                    lines.append(f"{cls['name']}.{constant['name']} = {constant['value'].replace("inf", "math.huge")}")

            # Enums
            for enum in cls.get("enums", []):
                lines.append("")
                lines.append(f"--- @enum {cls['name']}.{enum['name']}")
                lines.append(f"{cls['name']}.{enum['name']} = {{")
                for value in enum["values"]:
                    lines.append(f"\t{value['name']} = {value['value']},")
                lines.append("}")
            
            # Methods
            # We don't repeat StringName methods because they are the same as String's, which are both aliases to `string`
            if cls["name"] != "StringName":
                for method in cls.get("methods", []):
                    # Just skip methods that have names that are keywords in Lua
                    if method["name"] in KEYWORD_MAP:
                        continue

                    lines.append("")
                    if method["is_static"]:
                        lines.append("--- static")
                    if is_string:
                        lines.append(f"--- @param self string")
                    for arg in method.get('arguments', []):
                        lines.append(f"--- @param {_arg_name(arg['name'])} {_arg_type(arg['type'], arg.get('default_value'))}{' Default: ' + arg.get('default_value', '') if arg.get('default_value') else ''}")
                    if return_type := method.get("return_type"):
                        lines.append(f"--- @return {_arg_type(return_type)}")
                    args = [_arg_name(arg["name"]) for arg in method.get("arguments", [])]
                    if is_string:
                        args.insert(0, "self")
                    if method["is_vararg"]:
                        args.append("...")
                    lines.append(f"""function {
                            'string' if is_string else cls['name']
                        }{
                            '.' if is_string else ':'
                        }{
                            method['name']
                        }({
                            ', '.join(args)
                        }) end""")

        lines.append("")

    lines.append("")
    return lines


def generate_classes(
    classes: list[Class],
    singletons: list[ArgumentOrSingletonOrMember],
) -> list[str]:
    lines = []

    # Now its specializations
    for cls in classes:
        # Header
        lines.append(f"{_generate_section(cls['name'])}")
        lines.append(f"--- @class {cls['name']}{': ' + cls.get('inherits', '') if cls.get('inherits') else ''}")

        # Properties
        for property in cls.get("properties", []):
            lines.append(f"--- @field {property['name']} {_arg_type(property['type'])}")
        
        lines.append(f"{cls['name']} = {{}}")

        # Constructor
        if not get_class_singleton_name(cls, singletons) and cls["is_instantiable"]:
            lines.append("")
            lines.append(f"--- @return {cls['name']}")
            lines.append(f"function {cls['name']}:new() end")

        # Constants
        if constants := cls.get("constants", []):
            lines.append("")
            for constant in constants:
                lines.append(f"{cls['name']}.{constant['name']} = {constant['value']}")

        # Enums
        for enum in cls.get("enums", []):
            lines.append("")
            lines.append(f"--- @alias {cls['name']}.{enum['name']} {' | '.join(f"`{cls['name']}.{value['name']}`" for value in enum['values'])}")
            for value in enum["values"]:
                lines.append(f"{cls['name']}.{value['name']} = {value['value']}")
        
        # Methods
        for method in cls.get("methods", []):
            # Just skip methods that have names that are keywords in Lua
            if method["name"] in KEYWORD_MAP:
                continue

            lines.append("")
            if method["is_static"]:
                lines.append("--- static")
            for arg in method.get('arguments', []):
                lines.append(f"--- @param {_arg_name(arg['name'])} {_arg_type(arg['type'], arg.get('default_value'))}{' Default: ' + arg.get('default_value', '') if arg.get('default_value') else ''}")
            if return_value := method.get("return_value"):
                lines.append(f"--- @return {_arg_type(return_value['type'])}")
            args = [_arg_name(arg["name"]) for arg in method.get("arguments", [])]
            if method['is_vararg']:
                args.append("...")
            lines.append(f"""function {
                    cls['name']
                }:{
                    method['name']
                }({
                    ', '.join(args)
                }) end""")

        lines.append("")

    lines.append("")
    return lines


def generate_utility_functions(
    utility_functions: list[UtilityFunction],
) -> list[str]:
    lines = []
    for f in utility_functions:
        lines.append("")
        for arg in f.get('arguments', []):
            lines.append(f"--- @param {_arg_name(arg['name'])} {_arg_type(arg['type'])}")
        if return_type := f.get("return_type"):
            lines.append(f"--- @return {_arg_type(return_type)}")
        args = [_arg_name(arg["name"]) for arg in f.get("arguments", [])]
        if f['is_vararg']:
            args.append("...")
        lines.append(f"""function {
                f['name']
            }({
                ', '.join(args)
            }) end""")
    # Extra utility function defined by Lua GDExtension: await
    lines.extend([
        "",
        "--- Yields the current coroutine until the passed signal is emitted.",
        "--- If an Object is passed, awaits for its 'completed' signal.",
        "--- @param awaitable Object | Signal",
        "--- @return any",
        "function await(awaitable) end",
    ])
    return lines


if __name__ == "__main__":
    main()
